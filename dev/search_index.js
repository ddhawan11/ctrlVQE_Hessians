var documenterSearchIndex = {"docs":
[{"location":"Operators/","page":"Operators","title":"Operators","text":"CurrentModule = CtrlVQE","category":"page"},{"location":"Operators/#Operators","page":"Operators","title":"Operators","text":"","category":"section"},{"location":"Operators/","page":"Operators","title":"Operators","text":"Modules = [CtrlVQE.Operators]","category":"page"},{"location":"Operators/#CtrlVQE.Operators","page":"Operators","title":"CtrlVQE.Operators","text":"Operators\n\nEnumerates various categories of Hermitian observable related to a device.\n\n\n\n\n\n","category":"module"},{"location":"Operators/#CtrlVQE.Operators.Channel","page":"Operators","title":"CtrlVQE.Operators.Channel","text":"Channel(i,t)\n\nAn individual drive term (indexed by i) at a specific time t.\n\nFor example, in a transmon device,     Channel(q,t) might represent Ω_q(t) exp(iν_qt) a_q + exp(-iν_qt) a_q,     the drive for a single qubit.\n\nNote that you are free to have multiple channels for each qubit,     or channels which operate on multiple qubits.\n\n\n\n\n\n","category":"type"},{"location":"Operators/#CtrlVQE.Operators.Coupling","page":"Operators","title":"CtrlVQE.Operators.Coupling","text":"Coupling(), aka COUPLING\n\nThe components of the static Hamiltonian which are non-local to any one qubit.\n\nFor example, in a transmon device,     Coupling() represents the sum _pq g_pq (a_pa_q + a_qa_p).\n\n\n\n\n\n","category":"type"},{"location":"Operators/#CtrlVQE.Operators.Drive","page":"Operators","title":"CtrlVQE.Operators.Drive","text":"Drive(t)\n\nThe sum of all drive terms at a specific time t.\n\nThis represents the sum of each Qubit(i),     where i iterates over each drive term in the device.\n\nFor example, in a transmon device,     Drive(t) might represent _q Ω_q(t) exp(iν_qt) a_q + exp(-iν_qt) a_q.\n\n\n\n\n\n","category":"type"},{"location":"Operators/#CtrlVQE.Operators.Gradient","page":"Operators","title":"CtrlVQE.Operators.Gradient","text":"Gradient(j,t)\n\nAn individual gradient operator (indexed by j) at a specific time t.\n\nThe gradient operators appear in the derivation of each gradient signal,     which are used to calculate analytical gradients of each variational parameter. The gradient operators are very closely related to individual channel operators,     but sufficiently distinct that they need to be treated separately.\n\nFor example, for a transmon device,     each channel operator Ω_q(t) exp(iν_qt) a_q + exp(-iν_qt) a_q     is associated with two gradient operators:\n\nexp(iν_qt) a_q + exp(-iν_qt) a_q\niexp(iν_qt) a_q - exp(-iν_qt) a_q\n\n\n\n\n\n","category":"type"},{"location":"Operators/#CtrlVQE.Operators.Hamiltonian","page":"Operators","title":"CtrlVQE.Operators.Hamiltonian","text":"Hamiltonian(t)\n\nThe full Hamiltonian at a specific time t.\n\nThis represents the sum of Static() and Drive(t).\n\n\n\n\n\n","category":"type"},{"location":"Operators/#CtrlVQE.Operators.Identity","page":"Operators","title":"CtrlVQE.Operators.Identity","text":"Identity(), aka IDENTITY\n\nThe identity operator.\n\n\n\n\n\n","category":"type"},{"location":"Operators/#CtrlVQE.Operators.Qubit","page":"Operators","title":"CtrlVQE.Operators.Qubit","text":"Qubit(q)\n\nThe component of the static Hamiltonian which is local to qubit q.\n\nFor example, in a transmon device,     Qubit(2) represents a term ω_q a_qa_q - δ_q2 a_qa_qa_q a_q.\n\n\n\n\n\n","category":"type"},{"location":"Operators/#CtrlVQE.Operators.Static","page":"Operators","title":"CtrlVQE.Operators.Static","text":"Static(), aka STATIC\n\nAll components of the static Hamiltonian.\n\nThis represents the sum of Uncoupled() and Coupled()\n\n\n\n\n\n","category":"type"},{"location":"Operators/#CtrlVQE.Operators.Uncoupled","page":"Operators","title":"CtrlVQE.Operators.Uncoupled","text":"Uncoupled(), aka UNCOUPLED\n\nThe components of the static Hamiltonian which are local to each qubit.\n\nThis represents the sum of each Qubit(q),     where q iterates over each qubit in the device.\n\nFor example, in a transmon device,     Uncoupled() represents the sum _q (ω_q a_qa_q - δ_q2 a_qa_qa_q a_q).\n\n\n\n\n\n","category":"type"},{"location":"LinearAlgebraTools/","page":"LinearAlgebraTools","title":"LinearAlgebraTools","text":"CurrentModule = CtrlVQE","category":"page"},{"location":"LinearAlgebraTools/#LinearAlgebraTools","page":"LinearAlgebraTools","title":"LinearAlgebraTools","text":"","category":"section"},{"location":"LinearAlgebraTools/","page":"LinearAlgebraTools","title":"LinearAlgebraTools","text":"Modules = [CtrlVQE.LinearAlgebraTools]","category":"page"},{"location":"LinearAlgebraTools/#CtrlVQE.LinearAlgebraTools","page":"LinearAlgebraTools","title":"CtrlVQE.LinearAlgebraTools","text":"LinearAlgebraTools\n\nImplement some frequently-used linear-algebraic operations.\n\nMuch of this functionality is available in Julia's standard LinearAlgebra library,     but the implementations here might take advantage of pre-allocated TempArrays     and (sometimes) efficient tensor contractions.\n\n\n\n\n\n","category":"module"},{"location":"LinearAlgebraTools/#CtrlVQE.LinearAlgebraTools.MatrixList","page":"LinearAlgebraTools","title":"CtrlVQE.LinearAlgebraTools.MatrixList","text":"MatrixList{T}\n\nSemantic alias for a 3d array which explicitly represents a list of matrices.\n\nThink of a MatrixList Ā as a list where each A[i] = Ā[:,:,i] is a matrix.\n\n\n\n\n\n","category":"type"},{"location":"LinearAlgebraTools/#CtrlVQE.LinearAlgebraTools.VectorList","page":"LinearAlgebraTools","title":"CtrlVQE.LinearAlgebraTools.VectorList","text":"VectorList{T}\n\nSemantic alias for Matrix which explicitly represents a distinct vector in each column.\n\nThink of a VectorList v̄ as a list where each v[i] = v̄[:,i] is a vector.\n\n\n\n\n\n","category":"type"},{"location":"LinearAlgebraTools/#CtrlVQE.LinearAlgebraTools.basisvector-Tuple{Int64, Int64}","page":"LinearAlgebraTools","title":"CtrlVQE.LinearAlgebraTools.basisvector","text":"basisvector(N::Int, i::Int)\n\nA vector of N Bools, all zero except for index i, which is one.\n\n\n\n\n\n","category":"method"},{"location":"LinearAlgebraTools/#CtrlVQE.LinearAlgebraTools.braket-Tuple{AbstractVector, AbstractMatrix, AbstractVector}","page":"LinearAlgebraTools","title":"CtrlVQE.LinearAlgebraTools.braket","text":"braket(x1::AbstractVector, A::AbstractMatrix, x2::AbstractVector)\n\nCompute the braket ⟨x1|A|x2⟩.\n\n\n\n\n\n","category":"method"},{"location":"LinearAlgebraTools/#CtrlVQE.LinearAlgebraTools.braket-Union{Tuple{F_}, Tuple{AbstractVector, Array{F_, 3}, AbstractVector}} where F_","page":"LinearAlgebraTools","title":"CtrlVQE.LinearAlgebraTools.braket","text":"braket(x1::AbstractVector, ā::MatrixList, x2::AbstractVector)\n\nCompute the braket ⟨x1|kron(ā)|x2⟩, but somewhat more efficiently.\n\n\n\n\n\n","category":"method"},{"location":"LinearAlgebraTools/#CtrlVQE.LinearAlgebraTools.cis!","page":"LinearAlgebraTools","title":"CtrlVQE.LinearAlgebraTools.cis!","text":"cis!(A::AbstractMatrix, x=1)\n\nCalculates exp(ixA) for a Hermitian matrix A.\n\nThe name comes from the identity exp(ix) = Cos(x) + I Sin(x).\n\nNote that this method mutates A itself to the calculated exponential. Therefore, A must have a complex float type, and it must not be an immutable view. For example, even though A must be Hermitian for this method to work correctly,     it can't actually be a LinearAlgebra.Hermitian view.\n\n\n\n\n\n","category":"function"},{"location":"LinearAlgebraTools/#CtrlVQE.LinearAlgebraTools.cis_type-Tuple{Any}","page":"LinearAlgebraTools","title":"CtrlVQE.LinearAlgebraTools.cis_type","text":"cis_type(x)\n\nPromote the number type of x to a complex float (compatible with cis operations).\n\nThe argument x may be a number, an array of numbers, or a number type itself.\n\n\n\n\n\n","category":"method"},{"location":"LinearAlgebraTools/#CtrlVQE.LinearAlgebraTools.expectation-Tuple{AbstractMatrix, AbstractVector}","page":"LinearAlgebraTools","title":"CtrlVQE.LinearAlgebraTools.expectation","text":"expectation(A::AbstractMatrix, x::AbstractVector)\n\nCompute the braket xAx.\n\n\n\n\n\n","category":"method"},{"location":"LinearAlgebraTools/#CtrlVQE.LinearAlgebraTools.expectation-Tuple{Array{T, 3} where T, AbstractVector}","page":"LinearAlgebraTools","title":"CtrlVQE.LinearAlgebraTools.expectation","text":"expectation(ā::MatrixList, x::AbstractVector)\n\nCompute the braket ⟨x|kron(ā)|x⟩, but somewhat more efficiently.\n\n\n\n\n\n","category":"method"},{"location":"LinearAlgebraTools/#CtrlVQE.LinearAlgebraTools.kron-Union{Tuple{Array{F, 3}}, Tuple{F}} where F","page":"LinearAlgebraTools","title":"CtrlVQE.LinearAlgebraTools.kron","text":"kron(Ā::MatrixList; result=nothing)\n\nThe kronecker product of each matrix in Ā.\n\n\n\n\n\n","category":"method"},{"location":"LinearAlgebraTools/#CtrlVQE.LinearAlgebraTools.kron-Union{Tuple{Matrix{F}}, Tuple{F}} where F","page":"LinearAlgebraTools","title":"CtrlVQE.LinearAlgebraTools.kron","text":"kron(v̄::VectorList; result=nothing)\n\nThe kronecker product of each vector in v̄.\n\nOrdering: [x1 x2] ⊗ [y1 y2] = [x1⋅y1  x1⋅y2  x2⋅y1  x2⋅y2]\n\nOptionally, pass a pre-allocated array of compatible type and shape as result.\n\n\n\n\n\n","category":"method"},{"location":"LinearAlgebraTools/#CtrlVQE.LinearAlgebraTools.rotate!","page":"LinearAlgebraTools","title":"CtrlVQE.LinearAlgebraTools.rotate!","text":"rotate!(R, x)\n\nApply the rotation R to the object x, mutating x.\n\nGenerally, R is a unitary (or orthogonal) matrix. If x is a vector, rotate! computes x  Rx. If x is a matrix, rotate! computes x  RxR.\n\nYou may also pass R as a MatrixList,     which is interpreted as a rotation with a factorized tensor structure. In other words, if r̄ is a MatrixList,     rotate!(r̄, x) is equivalent to rotate!(kron(r̄), x),     except that the former has a more efficient implementation.\n\nSince this method mutates x,     the number type of x must be sufficiently expressive. For example, if R is a unitary matrix, x had better be a vector of complex floats.\n\n\n\n\n\n","category":"function"},{"location":"Parameters/","page":"Parameters","title":"Parameters","text":"CurrentModule = CtrlVQE","category":"page"},{"location":"Parameters/#Parameters","page":"Parameters","title":"Parameters","text":"","category":"section"},{"location":"Parameters/","page":"Parameters","title":"Parameters","text":"Modules = [CtrlVQE.Parameters]","category":"page"},{"location":"Parameters/#CtrlVQE.Parameters","page":"Parameters","title":"CtrlVQE.Parameters","text":"Parameters\n\nStandardized interface for interacting with variational parameters.\n\nMost commonly implemented by Signals and Devices.\n\n\n\n\n\n","category":"module"},{"location":"Parameters/#CtrlVQE.Parameters.bind","page":"Parameters","title":"CtrlVQE.Parameters.bind","text":"bind(entity, x̄::AbstractVector)\n\nAssigns new values for each variational parameter in entity.\n\nImplementation\n\nThis method should mutate entity such that, for example,     the expression bind(entity, x̄); ȳ = values(entity); x̄ == ȳ evaluates true. There is no return value.\n\n\n\n\n\n","category":"function"},{"location":"Parameters/#CtrlVQE.Parameters.count","page":"Parameters","title":"CtrlVQE.Parameters.count","text":"count(entity)\n\nThe number of variational parameters in entity.\n\nImplementation\n\nMust return a non-negative integer.\n\n\n\n\n\n","category":"function"},{"location":"Parameters/#CtrlVQE.Parameters.names","page":"Parameters","title":"CtrlVQE.Parameters.names","text":"names(entity)\n\nAn ordered list of human-readable names for each variational parameter in entity.\n\nImplementation\n\nMust return a vector of strings.\n\n\n\n\n\n","category":"function"},{"location":"Parameters/#CtrlVQE.Parameters.values","page":"Parameters","title":"CtrlVQE.Parameters.values","text":"values(entity)\n\nAn ordered list of the numerical values for each variational parameter in entity.\n\nImplementation\n\nMust return a vector of some float type.\n\n\n\n\n\n","category":"function"},{"location":"QubitOperators/","page":"QubitOperators","title":"QubitOperators","text":"CurrentModule = CtrlVQE","category":"page"},{"location":"QubitOperators/#QubitOperators","page":"QubitOperators","title":"QubitOperators","text":"","category":"section"},{"location":"QubitOperators/","page":"QubitOperators","title":"QubitOperators","text":"Modules = [CtrlVQE.QubitOperators]","category":"page"},{"location":"QubitOperators/#CtrlVQE.QubitOperators","page":"QubitOperators","title":"CtrlVQE.QubitOperators","text":"QubitOperators\n\nInterfaces arbitrary physical Hilbert space with a strictly binary logical Hilbert space.\n\nNOTE: I don't especially like how this module is organized,     so consider this code subject to change.\n\n\n\n\n\n","category":"module"},{"location":"QubitOperators/#CtrlVQE.QubitOperators.driveframe-Tuple{AbstractMatrix, CtrlVQE.Devices.Device, Real}","page":"QubitOperators","title":"CtrlVQE.QubitOperators.driveframe","text":"driveframe(H::AbstractMatrix, device::Devices.Device, T::Real)\n\nRewrite a molcular Hamiltonian in the drive frame of a device at time T.\n\nThis first projects H onto the physical Hilbert space,     then evolves by the device's static Hamiltonian.\n\n\n\n\n\n","category":"method"},{"location":"QubitOperators/#CtrlVQE.QubitOperators.interactionframe-Tuple{AbstractMatrix, CtrlVQE.Devices.Device, Real}","page":"QubitOperators","title":"CtrlVQE.QubitOperators.interactionframe","text":"interactionframe(H::AbstractMatrix, device::Devices.Device, T::Real)\n\nRewrite a molcular Hamiltonian in the interaction frame of a device at time T.\n\nThis first projects H onto the physical Hilbert space,     then evolves by the uncoupled parts of a device's static Hamiltonian. This is supposed to approximate the drive frame while remaining classically tractable.\n\n\n\n\n\n","category":"method"},{"location":"QubitOperators/#CtrlVQE.QubitOperators.localqubitisometries-Tuple{CtrlVQE.Devices.Device}","page":"QubitOperators","title":"CtrlVQE.QubitOperators.localqubitisometries","text":"localqubitprojectors(device::Devices.Device)\n\nA matrix list of local qubit isometries for each individual qubit in the device.\n\n\n\n\n\n","category":"method"},{"location":"QubitOperators/#CtrlVQE.QubitOperators.localqubitprojectors-Tuple{CtrlVQE.Devices.Device}","page":"QubitOperators","title":"CtrlVQE.QubitOperators.localqubitprojectors","text":"localqubitprojectors(device::Devices.Device)\n\nA matrix list of local qubit projectors for each individual qubit in the device.\n\n\n\n\n\n","category":"method"},{"location":"QubitOperators/#CtrlVQE.QubitOperators.nqubits-Tuple{AbstractVecOrMat}","page":"QubitOperators","title":"CtrlVQE.QubitOperators.nqubits","text":"nqubits(H)\n\nInfer the number of qubits of a statevector or matrix living in a logical qubit space.\n\nIn other words, calculates n assuming the dimension of H is 2^n.\n\n\n\n\n\n","category":"method"},{"location":"QubitOperators/#CtrlVQE.QubitOperators.project-Union{Tuple{F}, Tuple{AbstractVector{F}, CtrlVQE.Devices.Device}} where F","page":"QubitOperators","title":"CtrlVQE.QubitOperators.project","text":"project(A, device::Devices.Device)\n\nExtend a statevector or matrix living in a two-level space onto a physical Hilbert space.\n\n\n\n\n\n","category":"method"},{"location":"QubitOperators/#CtrlVQE.QubitOperators.qubitisometry-Tuple{CtrlVQE.Devices.Device}","page":"QubitOperators","title":"CtrlVQE.QubitOperators.qubitisometry","text":"qubitisometry(device::Devices.Device)\n\nAn isometry from the physical Hilbert space of a device onto a logical two-level space.\n\nIf Φ is the isometry, and |ψ⟩ is a statevector living in the full Hilbert space,     the vector Φ|ψ⟩ is a smaller vector living in the two-level space.\n\n\n\n\n\n","category":"method"},{"location":"QubitOperators/#CtrlVQE.QubitOperators.qubitprojector-Tuple{CtrlVQE.Devices.Device}","page":"QubitOperators","title":"CtrlVQE.QubitOperators.qubitprojector","text":"qubitprojector(device::Devices.Device)\n\nA projector from the physical Hilbert space of a device onto a logical two-level space.\n\nThe projector Π does not reduce the size of its operand;     it only removes support on the non-logical states. If you want to change the size, use qubitisometry instead.\n\n\n\n\n\n","category":"method"},{"location":"QubitOperators/#CtrlVQE.QubitOperators.reference-Tuple{AbstractMatrix}","page":"QubitOperators","title":"CtrlVQE.QubitOperators.reference","text":"reference(H)\n\nThe basis state which minimizes the matrix H.\n\n\n\n\n\n","category":"method"},{"location":"Signals/","page":"Signals","title":"Signals","text":"CurrentModule = CtrlVQE","category":"page"},{"location":"Signals/#Signals","page":"Signals","title":"Signals","text":"","category":"section"},{"location":"Signals/","page":"Signals","title":"Signals","text":"Modules = [\n    CtrlVQE.Signals,\n    CtrlVQE.Signals.ParametricSignals,\n    CtrlVQE.Signals.WindowedSignals,\n    CtrlVQE.Signals.CompositeSignals,\n    CtrlVQE.Signals.ModulatedSignals,\n]","category":"page"},{"location":"Signals/#CtrlVQE.Signals","page":"Signals","title":"CtrlVQE.Signals","text":"Signals\n\nTime-dependent functions suitable for control signals with variational parameters.\n\nThe main motivation of this module     is to provide a common interface for analytical gradients and optimization.\n\n\n\n\n\n","category":"module"},{"location":"Signals/#CtrlVQE.Signals.AbstractSignal","page":"Signals","title":"CtrlVQE.Signals.AbstractSignal","text":"AbstractSignal{P,R}\n\nSuper-type for all signal objects Ω(t).\n\nType Parameters\n\nP denotes the type of all variational parameters. Must be a real float.\nR denotes the type of Ω(t) itself. May be any number type.\n\nImplementation\n\nAny concrete sub-type S must implement all functions in the Parameters module.\n\nIn particular, Parameters.values(Ω::S) must return a vector of type P.\nIf you are trying to create your own signal type,   you probably want to implement a ParametricSignal,   which already has an implementation for the Parameters interface.\n\nIn addition, the following methods must be implemented:\n\n(Ω::S)(t::Real):       the actual function Ω(t). Must return a number of type R.\npartial(i::Int, Ω::S, t::Real):       the partial derivative Ωx_i evaluated at time t,       where x_i is Ω's i-th variational parameter (ie. Parameters.names(Ω)[i]).       Must return a number of type R.\nBase.string(Ω::S, names::AbstractVector{String}):       a human-readable description of the signal,       inserting each element of names in the place of the corresponding parameter.   For example, a complex constant signal might return a description like \"A + i B\",       where A and B are the \"names\" given by the names argument.\n\n\n\n\n\n","category":"type"},{"location":"Signals/#CtrlVQE.Signals.AbstractSignal-Union{Tuple{AbstractVector{<:Real}}, Tuple{R}, Tuple{P}} where {P, R}","page":"Signals","title":"CtrlVQE.Signals.AbstractSignal","text":"(signal::AbstractSignal{P,R})(t̄::AbstractVector{<:Real}; result=nothing)\n\nVectorized version. Returns a vector of type R.\n\nOptionally, pass a pre-allocated array of compatible type and shape as result.\n\n\n\n\n\n","category":"method"},{"location":"Signals/#CtrlVQE.Signals.AbstractSignal-Union{Tuple{Real}, Tuple{R}, Tuple{P}} where {P, R}","page":"Signals","title":"CtrlVQE.Signals.AbstractSignal","text":"(signal::AbstractSignal{P,R})(t::Real)\n\nThe signal at time t, ie. Ω(t). Returns a number of type R.\n\n\n\n\n\n","category":"method"},{"location":"Signals/#Base.string-Tuple{CtrlVQE.Signals.AbstractSignal, AbstractVector{String}}","page":"Signals","title":"Base.string","text":"Base.string(Ω::AbstractSignal, names::AbstractVector{String})\n\nSubstitutes the default name of each variational parameter for the ones in names.\n\n\n\n\n\n","category":"method"},{"location":"Signals/#Base.string-Tuple{CtrlVQE.Signals.AbstractSignal}","page":"Signals","title":"Base.string","text":"Base.string(Ω::AbstractSignal)\n\nA human-readable description of the signal. Returns type string.\n\n\n\n\n\n","category":"method"},{"location":"Signals/#CtrlVQE.Signals.integrate_partials-Union{Tuple{R}, Tuple{P}, Tuple{CtrlVQE.Signals.AbstractSignal{P, R}, AbstractVector, AbstractVector, AbstractVector}} where {P, R}","page":"Signals","title":"CtrlVQE.Signals.integrate_partials","text":"integrate_partials(signal::AbstractSignal{P,R}, τ̄, t̄, ϕ̄; result=nothing)\n\nIntegrates each partial derivative Ωx_i_t, modulated by a function ϕ(t).\n\nSpecifically, this method returns a vector of integrals I,     where I[i] is the real part of  ϕ(t)  Ωx_i_t dt.\n\nTaking the real part is a little ad hoc. If Ω and ϕ are complex functions -     let's just say Ω(t)=α(t)+i β(t) and ϕ(t)=ϕ_α(t) - i ϕ_β(t) -     the integrals become  ϕ_α(t)  αx_i_t dt +  ϕ_β(t)  βx_i_t dt. This turns out to be the relevant quantity in many gradient calculations.\n\nArguments\n\nsignal\nτ̄: a vector of time spacings, as given by Evolutions.trapezoidaltimegrid.\nt̄: a vector of time points, as given by Evolutions.trapezoidaltimegrid.\nϕ̄: a vector of the modulating function ϕ(t) evaluated at each point in t̄.\n\nOptionally, pass a pre-allocated array of compatible type and shape as result.\n\n\n\n\n\n","category":"method"},{"location":"Signals/#CtrlVQE.Signals.integrate_signal-Union{Tuple{R}, Tuple{P}, Tuple{CtrlVQE.Signals.AbstractSignal{P, R}, AbstractVector, AbstractVector, AbstractVector}} where {P, R}","page":"Signals","title":"CtrlVQE.Signals.integrate_signal","text":"integrate_signal(signal::AbstractSignal{P,R}, τ̄, t̄, ϕ̄; result=nothing)\n\nIntegrates a signal Ω(t), modulated by a function ϕ(t).\n\nSpecifically, this method returns the real part of  ϕ(t)  Ω(t) dt.\n\nTaking the real part is a little ad hoc. If Ω and ϕ are complex functions -     let's just say Ω(t)=α(t)+i β(t) and ϕ(t)=tϕ_β(t) + i ϕ_α(t) -     the integral becomes  tϕ_β(t)α(t) dt -  tϕ_α(t)β(t) dt. This turns out to be the relevant quantity in transmon frequency gradient calculations.\n\nArguments\n\nsignal\nτ̄: a vector of time spacings, as given by Evolutions.trapezoidaltimegrid.\nt̄: a vector of time points, as given by Evolutions.trapezoidaltimegrid.\nϕ̄: a vector of the modulating function ϕ(t) evaluated at each point in t̄.\n\n\n\n\n\n","category":"method"},{"location":"Signals/#CtrlVQE.Signals.partial-Union{Tuple{R}, Tuple{P}, Tuple{Int64, CtrlVQE.Signals.AbstractSignal{P, R}, AbstractVector{<:Real}}} where {P, R}","page":"Signals","title":"CtrlVQE.Signals.partial","text":"partial(\n    i::Int, signal::AbstractSignal{P,R}, t̄::AbstractVector{<:Real};\n    result=nothing,\n)\n\nVectorized version. Returns a vector of type R.\n\nOptionally, pass a pre-allocated array of compatible type and shape as result.\n\n\n\n\n\n","category":"method"},{"location":"Signals/#CtrlVQE.Signals.partial-Union{Tuple{R}, Tuple{P}, Tuple{Int64, CtrlVQE.Signals.AbstractSignal{P, R}, Real}} where {P, R}","page":"Signals","title":"CtrlVQE.Signals.partial","text":"partial(i::Int, signal::AbstractSignal{P,R}, t::Real)\n\nThe partial derivative Ωx_i_t. Returns a number of type R.\n\nHere x_i is the signal's i-th variational parameter     (ie. Parameters.names(signal)[i]).\n\n\n\n\n\n","category":"method"},{"location":"Signals/#CtrlVQE.Signals.ParametricSignals.ConstrainedSignal","page":"Signals","title":"CtrlVQE.Signals.ParametricSignals.ConstrainedSignal","text":"ConstrainedSignal(constrained::<:ParametricSignal, constraints::Vector{Symbol})\n\nThe parametric signal constrained, freezing all fields in constraints.\n\nFrozen parameters are omitted from the Parameters interface. In other words, they do not appear in Parameters.names or Parameters.values,     and they are not mutated by Parameters.bind.\n\n\n\n\n\n","category":"type"},{"location":"Signals/#CtrlVQE.Signals.ParametricSignals.ConstrainedSignal-Tuple{CtrlVQE.Signals.ParametricSignals.ParametricSignal, Vararg{Symbol}}","page":"Signals","title":"CtrlVQE.Signals.ParametricSignals.ConstrainedSignal","text":"ConstrainedSignal(constrained::ParametricSignal, constraints::Symbol...)\n\nAlternate constructor, letting each field be passed as its own argument.\n\n\n\n\n\n","category":"method"},{"location":"Signals/#CtrlVQE.Signals.ParametricSignals.ParametricSignal","page":"Signals","title":"CtrlVQE.Signals.ParametricSignals.ParametricSignal","text":"ParametricSignal{P,R} ... end\n\nSuper-type for user-defined signal objects Ω(t).\n\nType Parameters\n\nP denotes the type of all variational parameters. Must be a real float.\nR denotes the type of Ω(t) itself. May be any number type.\n\nImplementation\n\nAny concrete sub-type S must be a mutable struct,     and all of its variational parameters are of type P. By default, all fields of type P are treated as variational parameters. You may optionally change this by implementing parameters(::S),     which should return a vector of each variational parameter of S. But before you do that,     consider whether a ConstrainedSignal provides the desired behavior.\n\nThe following methods must be implemented:\n\n(Ω::S)(t::Real):       the actual function Ω(t). Must return a number of type R.\npartial(i::Int, Ω::S, t::Real):       the partial derivative Ωx_i evaluated at time t,       where x_i is Ω's i-th variational parameter (ie. Parameters.names(Ω)[i]).       Must return a number of type R.\nBase.string(Ω::S, names::AbstractVector{String}):       a human-readable description of the signal,       inserting each element of names in the place of the corresponding parameter.   For example, a complex constant signal might return a description like \"A + i B\",       where A and B are the \"names\" given by the names argument.\n\n\n\n\n\n","category":"type"},{"location":"Signals/#CtrlVQE.Signals.ParametricSignals.parameters-Union{Tuple{S}, Tuple{R}, Tuple{P}} where {P, R, S<:CtrlVQE.Signals.ParametricSignals.ParametricSignal{P, R}}","page":"Signals","title":"CtrlVQE.Signals.ParametricSignals.parameters","text":"parameters(::S<:ParametricSignal{P,R})\n\nA vector of all the variational parameters in a signal of type S.\n\n\n\n\n\n","category":"method"},{"location":"Signals/#CtrlVQE.Signals.ParametricSignals.parameters-Union{Tuple{Type{S}}, Tuple{S}, Tuple{R}, Tuple{P}} where {P, R, S<:CtrlVQE.Signals.ParametricSignals.ParametricSignal{P, R}}","page":"Signals","title":"CtrlVQE.Signals.ParametricSignals.parameters","text":"parameters(::Type{S<:ParametricSignal{P,R}})\n\nA vector of all the variational parameters in a signal of type S.\n\n\n\n\n\n","category":"method"},{"location":"Signals/#CtrlVQE.Signals.WindowedSignals.WindowedSignal","page":"Signals","title":"CtrlVQE.Signals.WindowedSignals.WindowedSignal","text":"WindowedSignal(windows, starttimes)\n\nA signal which applies a different function for each window.\n\nArguments\n\nwindows: a vector of signals\nstarttimes: a vector of times transitioning each window\n\nBoth windows and starttimes have the same length;     starttimes[i] indicates when windows[i] begins.\n\nThis signal is undefined for times t < starttimes[1]. Normally, starttimes[1] == 0.\n\nNote that each window must share the same type parameters P and R.\n\n\n\n\n\n","category":"type"},{"location":"Signals/#CtrlVQE.Signals.WindowedSignals.get_window_from_parameter-Tuple{CtrlVQE.Signals.WindowedSignals.WindowedSignal, Int64}","page":"Signals","title":"CtrlVQE.Signals.WindowedSignals.get_window_from_parameter","text":"get_window_from_parameter(signal::WindowedSignal, i::Int)\n\nIdentify the window index given a parameter index (by counting parameters in windows).\n\n\n\n\n\n","category":"method"},{"location":"Signals/#CtrlVQE.Signals.WindowedSignals.get_window_from_time-Tuple{CtrlVQE.Signals.WindowedSignals.WindowedSignal, Real}","page":"Signals","title":"CtrlVQE.Signals.WindowedSignals.get_window_from_time","text":"get_window_from_time(signal::WindowedSignal, t::Real)\n\nIdentify the window index given the time (by inspecting starttimes).\n\n\n\n\n\n","category":"method"},{"location":"Signals/#CtrlVQE.Signals.CompositeSignals.CompositeSignal","page":"Signals","title":"CtrlVQE.Signals.CompositeSignals.CompositeSignal","text":"CompositeSignal(components::AbstractVector{<:AbstractSignal{P,R}})\n\nA signal which is the sum of each sub-signal in components.\n\nNote that each component must share the same type parameters P and R.\n\n\n\n\n\n","category":"type"},{"location":"Signals/#CtrlVQE.Signals.CompositeSignals.CompositeSignal-Union{Tuple{Vararg{CtrlVQE.Signals.AbstractSignal{P, R}}}, Tuple{R}, Tuple{P}} where {P, R}","page":"Signals","title":"CtrlVQE.Signals.CompositeSignals.CompositeSignal","text":"CompositeSignal(components::AbstractSignal...)\n\nAlternate constructor, letting each component be passed as its own argument.\n\n\n\n\n\n","category":"method"},{"location":"Signals/#CtrlVQE.Signals.ModulatedSignals.ModulatedSignal","page":"Signals","title":"CtrlVQE.Signals.ModulatedSignals.ModulatedSignal","text":"ModulatedSignal(components::AbstractVector{<:AbstractSignal{P,R}})\n\nA signal which is the product of each sub-signal in components.\n\nNote that each component must share the same type parameters P and R.\n\n\n\n\n\n","category":"type"},{"location":"Signals/#CtrlVQE.Signals.ModulatedSignals.ModulatedSignal-Union{Tuple{Vararg{CtrlVQE.Signals.AbstractSignal{P, R}}}, Tuple{R}, Tuple{P}} where {P, R}","page":"Signals","title":"CtrlVQE.Signals.ModulatedSignals.ModulatedSignal","text":"ModulatedSignal(components::AbstractSignal...)\n\nAlternate constructor, letting each component be passed as its own argument.\n\n\n\n\n\n","category":"method"},{"location":"Signals/#Constant-Signals","page":"Signals","title":"Constant Signals","text":"","category":"section"},{"location":"Signals/","page":"Signals","title":"Signals","text":"Modules = [CtrlVQE.Signals.ConstantSignals]","category":"page"},{"location":"Signals/#CtrlVQE.Signals.ConstantSignals.ComplexConstant","page":"Signals","title":"CtrlVQE.Signals.ConstantSignals.ComplexConstant","text":"ComplexConstant(A::F, B::F) where {F<:AbstractFloat}\n\nThe constant complex signal Ω(t) = A + iB.\n\n\n\n\n\n","category":"type"},{"location":"Signals/#CtrlVQE.Signals.ConstantSignals.Constant","page":"Signals","title":"CtrlVQE.Signals.ConstantSignals.Constant","text":"Constant(A::F) where {F<:AbstractFloat}\n\nThe constant real signal Ω(t) = A.\n\n\n\n\n\n","category":"type"},{"location":"Signals/#CtrlVQE.Signals.ConstantSignals.PolarComplexConstant","page":"Signals","title":"CtrlVQE.Signals.ConstantSignals.PolarComplexConstant","text":"PolarComplexConstant(r::F, ϕ::F) where {F<:AbstractFloat}\n\nThe constant complex signal Ω(t) = r exp(iϕ).\n\n\n\n\n\n","category":"type"},{"location":"Signals/#Interval-Signals","page":"Signals","title":"Interval Signals","text":"","category":"section"},{"location":"Signals/","page":"Signals","title":"Signals","text":"Modules = [CtrlVQE.Signals.IntervalSignals]","category":"page"},{"location":"Signals/#CtrlVQE.Signals.IntervalSignals.ComplexInterval","page":"Signals","title":"CtrlVQE.Signals.IntervalSignals.ComplexInterval","text":"ComplexInterval(A::F, B::F, s1::F, s2::F) where {F<:AbstractFloat}\n\nThe piecewise signal Ω(t) = A + iB, for times t∈[s1,s2), and Ω(t) = 0 otherwise.\n\n\n\n\n\n","category":"type"},{"location":"Signals/#CtrlVQE.Signals.IntervalSignals.Interval","page":"Signals","title":"CtrlVQE.Signals.IntervalSignals.Interval","text":"Interval(A::F, s1::F, s2::F) where {F<:AbstractFloat}\n\nThe piecewise signal Ω(t) = A, for times t∈[s1,s2), and Ω(t) = 0 otherwise.\n\n\n\n\n\n","category":"type"},{"location":"Signals/#Step-Function-Signals","page":"Signals","title":"Step Function Signals","text":"","category":"section"},{"location":"Signals/","page":"Signals","title":"Signals","text":"Modules = [CtrlVQE.Signals.StepFunctionSignals]","category":"page"},{"location":"Signals/#CtrlVQE.Signals.StepFunctionSignals.StepFunction","page":"Signals","title":"CtrlVQE.Signals.StepFunctionSignals.StepFunction","text":"StepFunction(A::F, s::F) where {F<:AbstractFloat}\n\nThe piecewise signal Ω(t) = AΘ(t-s), where Θ is the Heaviside step function.\n\n\n\n\n\n","category":"type"},{"location":"Signals/#Gaussian-Signals","page":"Signals","title":"Gaussian Signals","text":"","category":"section"},{"location":"Signals/","page":"Signals","title":"Signals","text":"Modules = [CtrlVQE.Signals.GaussianSignals]","category":"page"},{"location":"Signals/#CtrlVQE.Signals.GaussianSignals.Gaussian","page":"Signals","title":"CtrlVQE.Signals.GaussianSignals.Gaussian","text":"Gaussian(A::F, σ::F, s::F) where {F<:AbstractFloat}\n\nA Gaussian real signal Ω(t) = A exp( -((t-s)σ)^2  2).\n\n\n\n\n\n","category":"type"},{"location":"Devices/","page":"Devices","title":"Devices","text":"CurrentModule = CtrlVQE","category":"page"},{"location":"Devices/#Devices","page":"Devices","title":"Devices","text":"","category":"section"},{"location":"Devices/","page":"Devices","title":"Devices","text":"Modules = [\n    CtrlVQE.Devices,\n    CtrlVQE.Devices.LocallyDrivenDevices,\n]","category":"page"},{"location":"Devices/#CtrlVQE.Devices","page":"Devices","title":"CtrlVQE.Devices","text":"Devices\n\nIn silico representation of quantum devices, in which quantum states evolve in time.\n\nIn this package,     the \"static\" components (ie. qubit frequencies, couplings, etc.)     and the \"drive\" components (ie. control signal, variational parameters, etc.)     are all integrated into a single Device object. All you need to know how a quantum state ψ evolves up time T is in the device.\n\n\n\n\n\n","category":"module"},{"location":"Devices/#CtrlVQE.Devices.Device","page":"Devices","title":"CtrlVQE.Devices.Device","text":"Device\n\nSuper-type for all device objects.\n\nImplementation\n\nAny concrete sub-type D must implement all functions in the Parameters module.\n\nIn particular, if any static operators in your device depend on variational parameters,   you should consult the \"Note on Caching\" below.\n\nIn addition, all methods in the following sections must be implemented.\n\nCounting methods\nAlgebra methods\nOperator methods\nType methods\nGradient methods\n\nIf your device's drive channels are all local,     you should implement a LocallyDrivenDevice,     which has a few extra requirements.\n\nCounting methods:\n\nnqubits(::D): the number of qubits in the device - call this n.\nnlevels(::D): the number of physical levels in each \"qubit\" - call this m.\nndrives(::D): the number of distinct drive channels.\nngrades(::D): the number of distinct gradient operators.\n\nEach of these methods returns an integer.\n\nAlgebra methods:\n\nlocalloweringoperator(::D):       an m × m matrix applying the lowering operator a to a single qubit.\n\nThis method should define result=nothing as a keyword argument;     when passed, use it as the array to store your result in.\n\nOperator methods:\n\nqubithamiltonian(::D, ā, q::Int):       the static components of the device Hamiltonian local to qubit q.\nstaticcoupling(::D, ā):       the static components of the device Hamiltonian nonlocal to any one qubit.\ndriveoperator(::D, ā, i::Int, t::Real):       the distinct drive operator for channel i at time t\ngradeoperator(::D, ā, j::Int, t::Real):       the distinct gradient operator indexed by j at time t\n\nEach of these methods should define result=nothing as a keyword argument;     when passed, use it as the array to store your result in.\n\nEach of these methods takes a 3darray ā;     the annihilation operator a_q is given by the matrix ā[:,:,q]. These methods should construct a new matrix as a function of each a_q. Usually, each ā[:,:,q] is defined on the full Hilbert space (ie. m^n × m^n),     but sometimes the code exploits a simple tensor structure     by passing in local m × m operators instead,     so do not assume a specific size a priori.\n\nThe annihilation operators a_q and their adjoints a_q form a complete algebra,     so it is always possible to express any operator given just ā. For example, the Pauli spin matrices in a two-level system can be expressed     as X=a+a, Y=i(a-a), and Z=aa. If you really want to write your operators as functions of something other than a_q,     you may \"hack\" in a new algebra by implementing new methods     for this module's eltype_algebra, algebra, and localalgebra functions.\n\nType methods:\n\neltype_localloweringoperator(::D)\neltype_qubithamiltonian(::D)\neltype_staticcoupling(::D)\neltype_driveoperator(::D)\neltype_gradeoperator(::D)\n\nEach of these methods gives the number type of the corresponding operator. Implement these methods based only on your implementation of the methods,     ie. they should be independent of the type of ā.\n\nGradient methods:\n\ngradient(::D, τ̄, t̄, ϕ̄):       the gradient vector for each variational parameter in the device.\n\nEach partial is generally an integral over at least one gradient signal. The arguments τ̄ and t̄ are time spacings and time grids,     as given by Evolutions.trapezoidaltimegrid. The argument ϕ̄ is a 2d array; ϕ̄[:,:,j] contains the jth gradient signal     ϕ_j(t) evaluated at each point in t̄. An integral f(ϕ_j(t) t)dt is computed as sum( f.(ϕ̄[:,:,j], t̄) .* τ̄ ).\n\nThis method should define result=nothing as a keyword argument;     when passed, use it as the array to store your result in.\n\nNotes on Caching\n\nThis module uses the Memoization package to cache some arrays as they are calculated.\n\nThis does not apply to any method which depends on an absolute time t,     though it does apply to methods depending only on a relative time τ. For example, the propagator for a static Hamiltonian is cached,     but not one for a drive Hamiltonian. No caching happens for any method if its result keyword argument is used.\n\nUsually, variational parameters only affect time-dependent methods,     but if any of your device's static operators do depend on a variational parameter,     you should be careful to empty the cache when Parameters.bind is called.\n\nYou can completely clear everything in the cache with:\n\nMemoization.empty_all_caches!()\n\nAlternatively, selectively clear caches for affected functions via:\n\nMemoization.empty_cache!(fn)\n\nI don't know if it's possible to selectively clear cached values for specific methods. If it can be done, it would require obtaining the actual Dict     being used as a cache for a particular function,     figuring out exactly how that cache is indexed,     and manually removing elements matching your targeted method signature.\n\n\n\n\n\n","category":"type"},{"location":"Devices/#Base.eltype-Tuple{CtrlVQE.Operators.OperatorType, CtrlVQE.Devices.Device}","page":"Devices","title":"Base.eltype","text":"Base.eltype(op::Operators.OperatorType, device::Device[, basis::Bases.BasisType])\n\nThe number type of the matrix returned by operator(op, device, basis).\n\nWhen omitted, the basis defaults to Bases.OCCUPATION.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.algebra","page":"Devices","title":"CtrlVQE.Devices.algebra","text":"algebra(device::Device[, basis::Bases.BasisType])\n\nA matrix list ā, where ā[:,:,q] represents the annihilation operator a_q.\n\nWhen omitted, the basis defaults to Bases.OCCUPATION.\n\nEach ā[:,:,q] acts globally on the full Hilbert space of the device,     even in bases where it acts trivially on states outside the local space of qubit q. To construct local operators, use localalgebra instead.\n\n\n\n\n\n","category":"function"},{"location":"Devices/#CtrlVQE.Devices.basisrotation-Tuple{CtrlVQE.Bases.BasisType, CtrlVQE.Bases.BasisType, CtrlVQE.Devices.Device}","page":"Devices","title":"CtrlVQE.Devices.basisrotation","text":"basisrotation(tgt::Bases.BasisType, src::Bases.BasisType, device::Device)\n\nCalculate the basis rotation U which transforms ψ_src  ψ_tgt = Uψ_src.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.basisrotation-Tuple{CtrlVQE.Bases.LocalBasis, CtrlVQE.Bases.LocalBasis, CtrlVQE.Devices.Device, Int64}","page":"Devices","title":"CtrlVQE.Devices.basisrotation","text":"basisrotation(tgt::Bases.LocalBasis, src::Bases.LocalBasis, device::Device, q::Int)\n\nSame as above, except that U acts on the local Hilbert space of qubit q.\n\nThis is used elsewhere for more efficient rotations exploiting tensor structure.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.braket-Tuple{CtrlVQE.Operators.OperatorType, CtrlVQE.Devices.Device, AbstractVector, AbstractVector}","page":"Devices","title":"CtrlVQE.Devices.braket","text":"braket(op, device[, basis], ψ1, ψ2)\n\nThe braket of an operator describing a device with respect to states ψ1 and ψ2.\n\nIf A is the operator specified by op, this method calculates ψ1Aψ2.\n\nArguments\n\nop::Operators.OperatorType: which operator to estimate (eg. static, drive, etc.).\ndevice::Device: which device is being described.\nbasis::Bases.BasisType: which basis the state ψ is represented in.       Defaults to Bases.OCCUPATION when omitted.\nψ1, ψ2: Statevectors defined over the full Hilbert space of the device.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.diagonalize","page":"Devices","title":"CtrlVQE.Devices.diagonalize","text":"diagonalize(basis::Bases.BasisType, device::Device)\n\nCompute the vector of eigenvalues Λ and the rotation matrix U for a given basis.\n\nU is an operator acting on the global Hilbert space of the device.\n\nThe result is packed into a LinearAlgebra.Eigen object,     but it may be unpacked by Λ, U = diagonalize(basis, device).\n\ndiagonalize(basis::Bases.LocalBasis, device::Device, q::Int)\n\nSame as above, except that U acts on the local Hilbert space of qubit q.\n\nNote that you can still construct     the global rotation matrix of a local basis by using the first method.\n\n\n\n\n\n","category":"function"},{"location":"Devices/#CtrlVQE.Devices.driveoperator-Tuple{CtrlVQE.Devices.Device, Array{T, 3} where T, Int64, Real}","page":"Devices","title":"CtrlVQE.Devices.driveoperator","text":"driveoperator(device::Device, ā::MatrixList, i::Int, t::Real; result=nothing)\n\nThe distinct drive operator for channel i at time t.\n\nThis method is a function of annihilation operators a_q given by ā[:,:,q],     which are matrices acting globally on the physical Hilbert space. If device is a LocallyDrivenDevice,     the matrices may also act on a local physical Hilbert space for each individual qubit.\n\nOptionally, pass a pre-allocated array of compatible type and shape as result.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.eltype_algebra","page":"Devices","title":"CtrlVQE.Devices.eltype_algebra","text":"eltype_algebra(device::Device[, basis::Bases.BasisType])\n\nThe number type of each annihilation operator a_j represented in the given basis.\n\nWhen omitted, the basis defaults to Bases.OCCUPATION.\n\n\n\n\n\n","category":"function"},{"location":"Devices/#CtrlVQE.Devices.eltype_driveoperator-Tuple{CtrlVQE.Devices.Device}","page":"Devices","title":"CtrlVQE.Devices.eltype_driveoperator","text":"eltype_driveoperator(device::Device)\n\nThe number type of the time-dependent drive channels for this device.\n\nThe number type of the algebra ā is ignored for the purposes of this method.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.eltype_gradeoperator-Tuple{CtrlVQE.Devices.Device}","page":"Devices","title":"CtrlVQE.Devices.eltype_gradeoperator","text":"eltype_gradeoperator(device::Device)\n\nThe number type of the gradient operators for this device.\n\nThe number type of the algebra ā is ignored for the purposes of this method.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.eltype_localloweringoperator-Tuple{CtrlVQE.Devices.Device}","page":"Devices","title":"CtrlVQE.Devices.eltype_localloweringoperator","text":"eltype_localloweringoperator(device::Device)\n\nThe number type of a local lowering operator for this device.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.eltype_qubithamiltonian-Tuple{CtrlVQE.Devices.Device}","page":"Devices","title":"CtrlVQE.Devices.eltype_qubithamiltonian","text":"eltype_qubithamiltonian(device::Device)\n\nThe number type of the local static components of the Hamiltonian for this device.\n\nThe number type of the algebra ā is ignored for the purposes of this method.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.eltype_staticcoupling-Tuple{CtrlVQE.Devices.Device}","page":"Devices","title":"CtrlVQE.Devices.eltype_staticcoupling","text":"eltype_staticcoupling(device::Device)\n\nThe number type of the non-local static components of the Hamiltonian for this device.\n\nThe number type of the algebra ā is ignored for the purposes of this method.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.evolve!-Tuple{CtrlVQE.Operators.OperatorType, CtrlVQE.Devices.Device, Real, AbstractVecOrMat{<:Complex{<:AbstractFloat}}}","page":"Devices","title":"CtrlVQE.Devices.evolve!","text":"evolve!(op, device[, basis], t, ψ)\n\nPropagate a state ψ by a time t under the Hermitian op describing a device.\n\nThis function is identical to propagate!,     except that the cache is not used for intermediate propagator matrices,     and that it is undefined for time-dependent operators. Look to the Evolutions module for algorithms compatible with time-dependence!\n\nArguments\n\nop::Operators.OperatorType: which operator to evolve under (eg. static, drive, etc.).\ndevice::Device: which device is being described.\nbasis::Bases.BasisType: which basis the state ψ is represented in.       Defaults to Bases.OCCUPATION when omitted.\nt::Real: the amount to move forward in time by.\nψ: Either a vector or a matrix, defined over the full Hilbert space of the device.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.evolver-Tuple{CtrlVQE.Operators.OperatorType, CtrlVQE.Devices.Device, Real}","page":"Devices","title":"CtrlVQE.Devices.evolver","text":"evolver(op, device[, basis], t; kwargs...)\n\nA unitary propagator describing evolution under a Hermitian operator for an time t.\n\nThis function is identical to propagator,     except that the argument t is considered an absolute time so it is never cached,     and that it is undefined for time-dependent operators. It exists solely to perform rotating-frame rotations at every time-step     without worrying about over-caching.\n\nArguments\n\nop::Operators.OperatorType: which operator to evolve under (eg. static, drive, etc.).\ndevice::Device: which device is being described.\nbasis::Bases.BasisType: which basis the operator will be represented in.       Defaults to Bases.OCCUPATION when omitted.\nt::Real: the amount to move forward in time by.\n\nKeyword Arguments\n\nresult: a pre-allocated array of compatible type and shape, used to store the result.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.expectation-Tuple{CtrlVQE.Operators.OperatorType, CtrlVQE.Devices.Device, AbstractVector}","page":"Devices","title":"CtrlVQE.Devices.expectation","text":"expectation(op, device[, basis], ψ)\n\nThe expectation value of an operator describing a device with respect to the state ψ.\n\nIf A is the operator specified by op, this method calculates ψAψ.\n\nArguments\n\nop::Operators.OperatorType: which operator to estimate (eg. static, drive, etc.).\ndevice::Device: which device is being described.\nbasis::Bases.BasisType: which basis the state ψ is represented in.       Defaults to Bases.OCCUPATION when omitted.\nψ: A statevector defined over the full Hilbert space of the device.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.globalize-Union{Tuple{F}, Tuple{CtrlVQE.Devices.Device, AbstractMatrix{F}, Int64}} where F","page":"Devices","title":"CtrlVQE.Devices.globalize","text":"globalize(device::Device, op::AbstractMatrix, q::Int; result=nothing)\n\nExtend a local operator op acting on qubit q into the global Hilbert space.\n\nOptionally, pass a pre-allocated array of compatible type and shape as result.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.gradeoperator-Tuple{CtrlVQE.Devices.Device, Array{T, 3} where T, Int64, Real}","page":"Devices","title":"CtrlVQE.Devices.gradeoperator","text":"gradeoperator(device::Device, ā::MatrixList, j::Int, t::Real; result=nothing)\n\nThe distinct gradient operator indexed by j at time t.\n\nI have defined the \"gradient operator\" A_j as the Hermitian operator     for which the jth gradient signal is ϕ_j = λ(iA_j)ψ + ht.\n\nThis method is a function of annihilation operators a_q given by ā[:,:,q],     which are matrices acting globally on the physical Hilbert space. If device is a LocallyDrivenDevice,     the matrices may also act on a local physical Hilbert space for each individual qubit.\n\nOptionally, pass a pre-allocated array of compatible type and shape as result.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.gradient-Tuple{CtrlVQE.Devices.Device, AbstractVector, AbstractVector, AbstractMatrix}","page":"Devices","title":"CtrlVQE.Devices.gradient","text":"gradient(::Device, τ̄, t̄, ϕ̄; result=nothing)\n\nThe gradient vector of partials for each variational parameter in the device.\n\nEach partial is generally an integral over at least one gradient signal. The arguments τ̄ and t̄ are time spacings and time grids,     as given by Evolutions.trapezoidaltimegrid. The argument ϕ̄ is a 2d array; ϕ̄[:,:,j] contains the jth gradient signal     ϕ_j(t) evaluated at each point in t̄.\n\nOptionally, pass a pre-allocated array of compatible type and shape as result.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.localalgebra","page":"Devices","title":"CtrlVQE.Devices.localalgebra","text":"localalgebra(device::Device[, basis::Bases.LocalBasis])\n\nA matrix list ā, where ā[:,:,q] represents the annihilation operator a_q.\n\nWhen omitted, the basis defaults to Bases.OCCUPATION.\n\nEach ā[:,:,q] acts locally on the physical Hilbert space of qubit q. Note that you can construct global operators in a local basis by using algebra instead.\n\n\n\n\n\n","category":"function"},{"location":"Devices/#CtrlVQE.Devices.localbasisrotations-Tuple{CtrlVQE.Bases.LocalBasis, CtrlVQE.Bases.LocalBasis, CtrlVQE.Devices.Device}","page":"Devices","title":"CtrlVQE.Devices.localbasisrotations","text":"localbasisrotations(tgt::Bases.LocalBasis, src::Bases.LocalBasis, device::Device)\n\nA matrix list ū, where ū[:,:,q] is a local basis rotation on qubit q.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.localloweringoperator-Tuple{CtrlVQE.Devices.Device}","page":"Devices","title":"CtrlVQE.Devices.localloweringoperator","text":"localloweringoperator(device::Device; result=nothing)\n\nThe lowering operator a acting on the Hilbert space of a single physical qubit.\n\nOptionally, pass a pre-allocated array of compatible type and shape as result.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.localqubitevolvers-Tuple{CtrlVQE.Devices.Device, Real}","page":"Devices","title":"CtrlVQE.Devices.localqubitevolvers","text":"localqubitevolvers(device[, basis], τ; kwargs...)\n\nA matrix list ū, where each ū[:,:,q] is a propagator for a local qubit hamiltonian.\n\nThis function is identical to localqubitevolvers,     except that the argument t is considered an absolute time so it is never cached.\n\nArguments\n\ndevice::Device: which device is being described.\nbasis::Bases.BasisType: which basis the operator will be represented in.       Defaults to Bases.OCCUPATION when omitted.\nτ::Real: the amount to move forward in time by.       Note that the propagation is only approximate for time-dependent operators.       The smaller τ is, the more accurate the approximation.\n\nKeyword Arguments\n\nresult: a pre-allocated array of compatible type and shape, used to store the result.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.localqubitoperators-Tuple{CtrlVQE.Devices.Device}","page":"Devices","title":"CtrlVQE.Devices.localqubitoperators","text":"localqubitoperators(device[, basis]; kwargs...)\n\nA matrix list h̄, where each h̄[:,:,q] represents a local qubit hamiltonian.\n\nArguments\n\ndevice::Device: which device is being described.\nbasis::Bases.BasisType: which basis the operators will be represented in.       Defaults to Bases.OCCUPATION when omitted.\n\nKeyword Arguments\n\nresult: a pre-allocated array of compatible type and shape, used to store the result.\nlocalqubitoperators(device, basis, :cache)\n\nFor internal use only. The extra positional argument enables dispatch to a cached function when appropriate.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.localqubitpropagators-Tuple{CtrlVQE.Devices.Device, Real}","page":"Devices","title":"CtrlVQE.Devices.localqubitpropagators","text":"localqubitpropagators(device[, basis], τ; kwargs...)\n\nA matrix list ū, where each ū[:,:,q] is a propagator for a local qubit hamiltonian.\n\nArguments\n\ndevice::Device: which device is being described.\nbasis::Bases.BasisType: which basis the operator will be represented in.       Defaults to Bases.OCCUPATION when omitted.\nτ::Real: the amount to move forward in time by.\n\nKeyword Arguments\n\nresult: a pre-allocated array of compatible type and shape, used to store the result.\nlocalqubitpropagators(device, basis, τ, :cache)\n\nFor internal use only. The extra positional argument enables dispatch to a cached function when appropriate.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.ndrives-Tuple{CtrlVQE.Devices.Device}","page":"Devices","title":"CtrlVQE.Devices.ndrives","text":"ndrives(device::Device)\n\nThe number of distinct drive channels.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.ngrades-Tuple{CtrlVQE.Devices.Device}","page":"Devices","title":"CtrlVQE.Devices.ngrades","text":"ngrades(device::Device)\n\nThe number of distinct gradient operators.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.nlevels-Tuple{CtrlVQE.Devices.Device}","page":"Devices","title":"CtrlVQE.Devices.nlevels","text":"nlevels(device::Device)\n\nThe number of physical levels in each \"qubit\".\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.nqubits-Tuple{CtrlVQE.Devices.Device}","page":"Devices","title":"CtrlVQE.Devices.nqubits","text":"nqubits(device::Device)\n\nThe number of qubits in the device.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.nstates-Tuple{CtrlVQE.Devices.Device}","page":"Devices","title":"CtrlVQE.Devices.nstates","text":"nstates(device::Device)\n\nThe total number of states in the physical Hilbert space of the device.\n\n(This is as opposed to nlevels(device),     the number of states in the physical Hilbert space of a single independent qubit.)\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.operator-Tuple{CtrlVQE.Operators.OperatorType, CtrlVQE.Devices.Device}","page":"Devices","title":"CtrlVQE.Devices.operator","text":"operator(op, device[, basis]; kwargs...)\n\nA Hermitian operator describing a device, represented in the given basis.\n\nFor example, to construct the static Hamiltonian of a device in the dressed basis,     call operator(Operators.STATIC, device, Bases.DRESSED).\n\nArguments\n\nop::Operators.OperatorType: which operator to construct (eg. static, drive, etc.).\ndevice::Device: which device is being described.\nbasis::Bases.BasisType: which basis the operator will be represented in.       Defaults to Bases.OCCUPATION when omitted.\n\nKeyword Arguments\n\nresult: a pre-allocated array of compatible type and shape, used to store the result.\noperator(op, device, basis, :cache)\n\nFor internal use only. The extra positional argument enables dispatch to a cached function when appropriate.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.propagate!-Tuple{CtrlVQE.Operators.OperatorType, CtrlVQE.Devices.Device, Real, AbstractVecOrMat{<:Complex{<:AbstractFloat}}}","page":"Devices","title":"CtrlVQE.Devices.propagate!","text":"propagate!(op, device[, basis], τ, ψ)\n\nPropagate a state ψ by a small time τ under the Hermitian op describing a device.\n\nArguments\n\nop::Operators.OperatorType: which operator to evolve under (eg. static, drive, etc.).\ndevice::Device: which device is being described.\nbasis::Bases.BasisType: which basis the state ψ is represented in.       Defaults to Bases.OCCUPATION when omitted.\nτ::Real: the amount to move forward in time by.       Note that the propagation is only approximate for time-dependent operators.       The smaller τ is, the more accurate the approximation.\nψ: Either a vector or a matrix, defined over the full Hilbert space of the device.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.propagator-Tuple{CtrlVQE.Operators.OperatorType, CtrlVQE.Devices.Device, Real}","page":"Devices","title":"CtrlVQE.Devices.propagator","text":"propagator(op, device[, basis], τ; kwargs...)\n\nA unitary propagator describing evolution under a Hermitian operator for a small time τ.\n\nArguments\n\nop::Operators.OperatorType: which operator to evolve under (eg. static, drive, etc.).\ndevice::Device: which device is being described.\nbasis::Bases.BasisType: which basis the operator will be represented in.       Defaults to Bases.OCCUPATION when omitted.\nτ::Real: the amount to move forward in time by.       Note that the propagation is only approximate for time-dependent operators.       The smaller τ is, the more accurate the approximation.\n\nKeyword Arguments\n\nresult: a pre-allocated array of compatible type and shape, used to store the result.\npropagator(op, device, basis, τ, :cache)\n\nFor internal use only. The extra positional argument enables dispatch to a cached function when appropriate.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.qubithamiltonian-Tuple{CtrlVQE.Devices.Device, Array{T, 3} where T, Int64}","page":"Devices","title":"CtrlVQE.Devices.qubithamiltonian","text":"qubithamiltonian(device::Device, ā::MatrixList, q::Int; result=nothing)\n\nThe static components of the device Hamiltonian local to qubit q.\n\nThis method is a function of annihilation operators a_q given by ā[:,:,q],     which may be matrices acting on a physical Hilbert space either globally or locally.\n\nOptionally, pass a pre-allocated array of compatible type and shape as result.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.staticcoupling-Tuple{CtrlVQE.Devices.Device, Array{T, 3} where T}","page":"Devices","title":"CtrlVQE.Devices.staticcoupling","text":"staticcoupling(device::Device, ā::MatrixList, q::Int; result=nothing)\n\nThe static components of the device Hamiltonian nonlocal to any one qubit.\n\nThis method is a function of annihilation operators a_q given by ā[:,:,q],     which are matrices acting globally on the physical Hilbert space.\n\nOptionally, pass a pre-allocated array of compatible type and shape as result.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.LocallyDrivenDevices.LocallyDrivenDevice","page":"Devices","title":"CtrlVQE.Devices.LocallyDrivenDevices.LocallyDrivenDevice","text":"LocallyDrivenDevice\n\nSuper-type for device objects whose drive channels act locally on individual qubits.\n\nInherit from this type if your driveoperator and gradeoperator methods     depend only on a single annihilation operator ā[:,:,q]. This enables more efficient propagation methods which exploit a tensor product structure.\n\nImplementation\n\nAny concrete sub-type D must implement everything required in the Device interface,     so consult the documentation for Device carefully.\n\nIn addition, the following methods must be implemented:\n\ndrivequbit(::D, i::Int): index of the qubit on which channel i is applied.\ngradequbit(::D, j::Int): index of the qubit associated with the jth gradient operator.\n\nIt's usually trivial to infer the channel index i associated with each gradient operator,     in which case gradequbit(device, j) = drivequbit(device, i),     but this is left as an implementation detail.\n\n\n\n\n\n","category":"type"},{"location":"Devices/#CtrlVQE.Devices.LocallyDrivenDevices.drivequbit-Tuple{CtrlVQE.Devices.LocallyDrivenDevices.LocallyDrivenDevice, Int64}","page":"Devices","title":"CtrlVQE.Devices.LocallyDrivenDevices.drivequbit","text":"drivequbit(device, i::Int)\n\nIndex of the qubit on which channel i is applied.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.LocallyDrivenDevices.gradequbit-Tuple{CtrlVQE.Devices.LocallyDrivenDevices.LocallyDrivenDevice, Int64}","page":"Devices","title":"CtrlVQE.Devices.LocallyDrivenDevices.gradequbit","text":"gradequbit(device, j::Int)\n\nIndex of the qubit associated with the jth gradient operator.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.LocallyDrivenDevices.localdriveoperators-Tuple{CtrlVQE.Devices.LocallyDrivenDevices.LocallyDrivenDevice, Real}","page":"Devices","title":"CtrlVQE.Devices.LocallyDrivenDevices.localdriveoperators","text":"localdriveoperators(device[, basis], t; kwargs...)\n\nA matrix list v̄, where v̄[:,:,q] represents a sum of all drives acting on qubit q.\n\nArguments\n\ndevice::Device: which device is being described.\nbasis::Bases.BasisType: which basis the operators will be represented in.       Defaults to Bases.OCCUPATION when omitted.\nt::Real: the time each drive operator is evaluated at.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#CtrlVQE.Devices.LocallyDrivenDevices.localdrivepropagators-Tuple{CtrlVQE.Devices.LocallyDrivenDevices.LocallyDrivenDevice, Real, Real}","page":"Devices","title":"CtrlVQE.Devices.LocallyDrivenDevices.localdrivepropagators","text":"localdrivepropagators(device[, basis], τ, t; kwargs...)\n\nA matrix list ū, where ū[:,:,q] is the propagator for a local drive term.\n\nArguments\n\ndevice::Device: which device is being described.\nbasis::Bases.BasisType: which basis the operators will be represented in.       Defaults to Bases.OCCUPATION when omitted.\nτ::Real: the amount to move forward in time by.       Note that the propagation is only approximate for time-dependent operators.       The smaller τ is, the more accurate the approximation.\nt::Real: the time each drive operator is evaluated at.\n\n\n\n\n\n","category":"method"},{"location":"Devices/#Transmon-Devices","page":"Devices","title":"Transmon Devices","text":"","category":"section"},{"location":"Devices/","page":"Devices","title":"Devices","text":"Modules = [CtrlVQE.Devices.TransmonDevices]","category":"page"},{"location":"Devices/#CtrlVQE.Devices.TransmonDevices.FixedFrequencyTransmonDevice","page":"Devices","title":"CtrlVQE.Devices.TransmonDevices.FixedFrequencyTransmonDevice","text":"FixedFrequencyTransmonDevice(ω̄, δ̄, ḡ, quples, q̄, ν̄, Ω̄, m)\n\nA transmon device, modeling for example IBM's superconducting quantum computers.\n\nVariational parameters include ONLY the shape parameters in each pulse. Pulse frequencies are \"frozen\".\n\nArguments\n\nω̄: a vector of angular frequencies specifying the resonance frequency of each qubit.\nδ̄: a vector of angular frequencies specifying the anharmonicity of each qubit.\nḡ: a vector of angular frequencies specifying the strength of each coupling.\nquples: a vector of Quple identifying whcih qubits participate in each coupling.\nq̄: a vector of indices specifying the target qubit for each drive channel.\nν̄: a vector of angular frequencies specifying the pulse frequencies for each channel.\nΩ̄: a vector of signals specifying the shape of the pulse for each channel.\nm: an integer specifying the number of physical levels to retain for each qubit.\n\n\n\n\n\n","category":"type"},{"location":"Devices/#CtrlVQE.Devices.TransmonDevices.TransmonDevice","page":"Devices","title":"CtrlVQE.Devices.TransmonDevices.TransmonDevice","text":"TransmonDevice(ω̄, δ̄, ḡ, quples, q̄, ν̄, Ω̄, m)\n\nA transmon device, modeling for example IBM's superconducting quantum computers.\n\nVariational parameters include the shape parameters in each pulse,     and the pulse frequencies.\n\nArguments\n\nω̄: a vector of angular frequencies specifying the resonance frequency of each qubit.\nδ̄: a vector of angular frequencies specifying the anharmonicity of each qubit.\nḡ: a vector of angular frequencies specifying the strength of each coupling.\nquples: a vector of Quple identifying whcih qubits participate in each coupling.\nq̄: a vector of indices specifying the target qubit for each drive channel.\nν̄: a vector of angular frequencies specifying the pulse frequencies for each channel.\nΩ̄: a vector of signals specifying the shape of the pulse for each channel.\nm: an integer specifying the number of physical levels to retain for each qubit.\n\n\n\n\n\n","category":"type"},{"location":"Evolutions/","page":"Evolutions","title":"Evolutions","text":"CurrentModule = CtrlVQE","category":"page"},{"location":"Evolutions/#Evolutions","page":"Evolutions","title":"Evolutions","text":"","category":"section"},{"location":"Evolutions/","page":"Evolutions","title":"Evolutions","text":"Modules = [CtrlVQE.Evolutions]","category":"page"},{"location":"Evolutions/#CtrlVQE.Evolutions","page":"Evolutions","title":"CtrlVQE.Evolutions","text":"Evolutions\n\nAlgorithms to run time evolution, and related constructs like gradient signals.\n\n\n\n\n\n","category":"module"},{"location":"Evolutions/#CtrlVQE.Evolutions.Algorithm","page":"Evolutions","title":"CtrlVQE.Evolutions.Algorithm","text":"Algorithm\n\nSuper-type for all evolution algorithms.\n\nImplementation\n\nAny concrete sub-type A must implement the following methods:\n\nevolve!(::A, device, basis, T, ψ; callback=nothing)\nevolve!(::A, device, T, ψ; callback=nothing)\n\nThe latter method should simply call the former,     using the basis which renders the algorithm most efficient. Please consult the documentation for evolve! for details on the implementation.\n\n\n\n\n\n","category":"type"},{"location":"Evolutions/#CtrlVQE.Evolutions.Direct","page":"Evolutions","title":"CtrlVQE.Evolutions.Direct","text":"Direct(r)\n\nA Trotterization method (using r steps) calculating drive terms in the rotation-frame.\n\nThe default basis for this algorithm is Bases.DRESSED,     since the rotating-frame evolution U_t  exp(-itH_0) happens at each step.\n\nThis algorithm exponentiates the matrix U_t V(t) U_t at each time step,     so it is not terribly efficient.\n\n\n\n\n\n","category":"type"},{"location":"Evolutions/#CtrlVQE.Evolutions.Rotate","page":"Evolutions","title":"CtrlVQE.Evolutions.Rotate","text":"Rotate(r)\n\nA Trotterization method (using r steps) alternately propagating static and drive terms.\n\nThe default basis for this algorithm is Bases.OCCUPATION.\n\n\n\n\n\n","category":"type"},{"location":"Evolutions/#CtrlVQE.Evolutions.evolve","page":"Evolutions","title":"CtrlVQE.Evolutions.evolve","text":"evolve([algorithm, ]device, [basis, ]T, ψ0; result=nothing, kwargs...)\n\nEvolve a state ψ0 by time T under a device Hamiltonian, without mutating ψ0.\n\nThis method simply copies ψ0 (to result if provided, or else to a new array),     then calls the mutating function evolve! on the copy. Please see evolve! for detailed documentation.\n\n\n\n\n\n","category":"function"},{"location":"Evolutions/#CtrlVQE.Evolutions.evolve!","page":"Evolutions","title":"CtrlVQE.Evolutions.evolve!","text":"evolve!([algorithm, ]device, [basis, ]T, ψ; callback=nothing)\n\nEvolve a state ψ by time T under a device Hamiltonian.\n\nThis method both mutates and returns ψ.\n\nArguments\n\nalgorithm::Algorithm: dispatches which evolution method to use.       Defaults to Rotate(1000) if omitted.\ndevice::Devices.Device: specifies which Hamiltonian to evolve under.\nbasis::Bases.BasisType: which basis ψ is represented in.       ALSO determines the basis in which calculations are carried out.       The default depends on the algorithm, so be sure to transform ψ accordingly.       For Rotate (the default algorithm), the default basis is Bases.OCCUPATION.\nT::Real: the total amount of time to evolve by.       The evolution is implicitly assumed to start at time t=0.\nψ: the initial statevector, defined on the full Hilbert space of the device.\n\nKeyword Arguments\n\ncallback: a function which is called at each iteration of the time evolution.       The function is passed three arguments:       - i: indexes the iteration       - t: the current time point       - ψ: the current statevector\n\n\n\n\n\n","category":"function"},{"location":"Evolutions/#CtrlVQE.Evolutions.gradientsignals-Tuple{CtrlVQE.Devices.Device, Vararg{Any}}","page":"Evolutions","title":"CtrlVQE.Evolutions.gradientsignals","text":"gradientsignals(device[, basis], T, ψ0, r, O; kwargs...)\n\nThe gradient signals associated with a given device Hamiltonian, and an observable O.\n\nGradient signals are used to calculate analytical derivatives of a control pulse.\n\nArguments\n\ndevice::Devices.Device: specifies which Hamiltonian to evolve under.       Also identifies each of the gradient operators used to calculate gradient signals.\nbasis::Bases.BasisType: which basis ψ is represented in.       ALSO determines the basis in which calculations are carried out.       Defaults to Bases.OCCUPATION.\nT::Real: the total duration of the pulse.\nψ0: the initial statevector, defined on the full Hilbert space of the device.\nr::Int: the number of time-steps to evaluate ϕ_j(t) for.\nO: a Hermitian observable, represented as a matrix.   Gradients are calculated with respect to the expectation ⟨O⟩ at time T.\n\nKeyword Arguments\n\nresult: an (optional) pre-allocated array to store gradient signals\nevolution: the evolution algorithm used to initialize the co-state |λ⟩.       The computation of the gradient signals always uses a Rotate-like algorithm,           but it begins with a plain-old time evolution.       This keyword argument controls how to do that initial time evolution only.       It defaults to Rotate(r).\ncallback: a function called at each iteration of the gradient signal calculation.       The function is passed three arguments:       - i: indexes the iteration       - t: the current time point       - ψ: the current statevector\n\nReturns\n\nA vector list ϕ̄, where each ϕ̄[:,j] is the gradient signal ϕ_j(t)     evaluated on a time grid given by trapezoidaltimegrid(T,r).\n\nExplanation\n\nA gradient signal ϕ_j(t) is defined with respect to a gradient operator A_j,     an observable O, a time-dependent state |ψ(t)⟩, and total pulse duration T.\n\nLet us define the expectation value E(T)  ψ(T)Oψ(T).\n\nDefine the co-state λ(t) as the (un-normalized) statevector     which satisfies E(T)=λ(t)ψ(t) for any time t∊[0,T]. The gradient signal is defined as ϕ_j(t)  λ(t)(iA_j)ψ(t) + ht.\n\ngradientsignals(device[, basis], T, ψ0, r, Ō; kwargs...)\n\nWhen the matrix argument O is replaced by a matrix list Ō,     each Ō[:,:,k] represents a different Hermitian observable O_k. In this case, a different set of gradient signals is computed for each O_k.\n\nReturns\n\nA 3d array ϕ̄, where each ϕ̄[:,j,k] is the gradient signal ϕ_j(t)     defined with respect to the observable O_k.\n\nExplanation\n\nMultiple sets of gradient signals may be useful     if you want to compute gradients with respect to multiple observables. For example, gradients with respect to a normalized molecular energy     include contributions from both a molecular Hamiltonian and a leakage operator. This method enables such calculations using only a single \"pass\" through time.\n\n\n\n\n\n","category":"method"},{"location":"Evolutions/#CtrlVQE.Evolutions.trapezoidaltimegrid-Tuple{Real, Int64}","page":"Evolutions","title":"CtrlVQE.Evolutions.trapezoidaltimegrid","text":"trapezoidaltimegrid(T::Real, r::Int)\n\nAll the tools needed to integrate over time using a simple trapezoidal rule.\n\nArguments\n\nT: the upper bound of the integral (0 is implicitly the lower bound).       If T is negative, |T| is used as the lower bound and 0 as the upper bound.\nr: the number of time steps.       Note this is the number of STEPS.       The number of time POINTS is r+1, since they include t=0.\n\nReturns\n\nτ: the length of each time step, simply Tr.\nτ̄: vector of r+1 time spacings to use as dt in integration.\nt̄: vector of r+1 time points\n\nThe integral _0^T f(t)dt is evaluated with sum(f.(t̄) .* τ̄).\n\nExplanation\n\nIntuitively, τ̄ is a vector giving τ for each time point. But careful! The sum of all τ̄ must match the length of the integral, ie. T. But there are r+1 points, and (r+1)⋅τ > T. How do we reconcile this? A \"Left Hand Sum\" would omit t=T from the time points;     a \"Right Hand Sum\" would omit t=0. The trapezoidal rule omits half a point from each.\n\nThat sounds awfully strange, but it's mathematically sound! We only integrate through half of each boundary time point t=0 and t=T. Thus, those points, and only those points, have a spacing of τ/2.\n\n\n\n\n\n","category":"method"},{"location":"Bases/","page":"Bases","title":"Bases","text":"CurrentModule = CtrlVQE","category":"page"},{"location":"Bases/#Bases","page":"Bases","title":"Bases","text":"","category":"section"},{"location":"Bases/","page":"Bases","title":"Bases","text":"Modules = [CtrlVQE.Bases]","category":"page"},{"location":"Bases/#CtrlVQE.Bases","page":"Bases","title":"CtrlVQE.Bases","text":"Bases\n\nEnumerates various linear-algebraic bases for representing statevectors and matrices.\n\n\n\n\n\n","category":"module"},{"location":"Bases/#CtrlVQE.Bases.Coordinate","page":"Bases","title":"CtrlVQE.Bases.Coordinate","text":"Coordinate(), aka COORDINATE\n\nThe eigenbasis of local quadrature operators Q  (a + a)2.\n\n\n\n\n\n","category":"type"},{"location":"Bases/#CtrlVQE.Bases.Dressed","page":"Bases","title":"CtrlVQE.Bases.Dressed","text":"Dressed(), aka DRESSED\n\nThe eigenbasis of the static Hamiltonian associated with a Device. Eigenvectors are ordered to maximize similarity with an identity matrix. Phases are fixed so that the diagonal is real.\n\n\n\n\n\n","category":"type"},{"location":"Bases/#CtrlVQE.Bases.Momentum","page":"Bases","title":"CtrlVQE.Bases.Momentum","text":"Momentum(), aka MOMENTUM\n\nThe eigenbasis of local quadrature operators P  i(a - a)2.\n\n\n\n\n\n","category":"type"},{"location":"Bases/#CtrlVQE.Bases.Occupation","page":"Bases","title":"CtrlVQE.Bases.Occupation","text":"Occupation(), aka OCCUPATION\n\nThe eigenbasis of local number operators n  aa. Generally equivalent to what is called the \"Z basis\", or the \"computational basis\".\n\n\n\n\n\n","category":"type"},{"location":"CostFunctions/","page":"Cost Functions","title":"Cost Functions","text":"CurrentModule = CtrlVQE","category":"page"},{"location":"CostFunctions/#Cost-Functions","page":"Cost Functions","title":"Cost Functions","text":"","category":"section"},{"location":"CostFunctions/","page":"Cost Functions","title":"Cost Functions","text":"Modules = [CtrlVQE.CostFunctions]","category":"page"},{"location":"CostFunctions/#CtrlVQE.CostFunctions","page":"Cost Functions","title":"CtrlVQE.CostFunctions","text":"CostFunctions\n\nInterfaces time-evolution and penalty functions to interface directly with optimization.\n\nEach distinct cost function is implemented in a sub-module,     alongside its gradient function. The sub-module implements a functions method which constructs a cost function     and its corresponding gradient function. Thus, all you need to run a gradient based optimization is:\n\nimport CostFunctions.MySubModule: functions\nf, g = functions(args...)\n\n\n\n\n\n","category":"module"},{"location":"CostFunctions/#CtrlVQE.CostFunctions.AbstractCostFunction","page":"Cost Functions","title":"CtrlVQE.CostFunctions.AbstractCostFunction","text":"AbstractCostFunction\n\nSuper-type for \"cost functions\", to be plugged directly into optimization algorithms.\n\nImplementation\n\nAny concrete sub-type CF must be a callable object, accepting a vector of parameters. That is, it must implement the function (f::CF)(x̄::AbstractVector).\n\n\n\n\n\n","category":"type"},{"location":"CostFunctions/#CtrlVQE.CostFunctions.AbstractCostFunction-Tuple{AbstractVector}","page":"Cost Functions","title":"CtrlVQE.CostFunctions.AbstractCostFunction","text":"(f::AbstractCostFunction)(x̄::AbstractVector)\n\nA cost function evaluated at the point in parameter space given by x̄.\n\n\n\n\n\n","category":"method"},{"location":"CostFunctions/#CtrlVQE.CostFunctions.AbstractGradientFunction","page":"Cost Functions","title":"CtrlVQE.CostFunctions.AbstractGradientFunction","text":"AbstractGradientFunction\n\nSuper-type for \"gradient functions\", to be plugged directly into optimization algorithms.\n\nEach gradient function is implicitly associated with a cost function.\n\nImplementation\n\nAny concrete sub-type GF must be a callable object,     accepting a vector of partial derivatives (to be calculated and filled in),     and a vector of parameters. That is, it must implement the function (g::GF)(∇f̄::AbstractVector,x̄::AbstractVector).\n\n\n\n\n\n","category":"type"},{"location":"CostFunctions/#CtrlVQE.CostFunctions.AbstractGradientFunction-Tuple{AbstractVector, AbstractVector}","page":"Cost Functions","title":"CtrlVQE.CostFunctions.AbstractGradientFunction","text":"(g::AbstractGradientFunction)(∇f̄::AbstractVector, x̄::AbstractVector)\n\nThe gradient of a function at the point in parameter space given by x̄.\n\nThe result is stored in the first argument ∇f̄, as well as returned.\n\n\n\n\n\n","category":"method"},{"location":"CostFunctions/#CtrlVQE.CostFunctions.AbstractGradientFunction-Tuple{AbstractVector}","page":"Cost Functions","title":"CtrlVQE.CostFunctions.AbstractGradientFunction","text":"(g::AbstractGradientFunction)(x̄::AbstractVector)\n\nThe gradient of a function at the point in parameter space given by x̄.\n\n\n\n\n\n","category":"method"},{"location":"CostFunctions/#CtrlVQE.CostFunctions.CompositeCostFunction","page":"Cost Functions","title":"CtrlVQE.CostFunctions.CompositeCostFunction","text":"CompositeCostFunction(f̄::Vector{AbstractCostFunction})\n\nThe sum of several other cost-functions.\n\nUse this eg. to combine an energy function with one or more penalty functions.\n\n\n\n\n\n","category":"type"},{"location":"CostFunctions/#CtrlVQE.CostFunctions.CompositeCostFunction-Tuple","page":"Cost Functions","title":"CtrlVQE.CostFunctions.CompositeCostFunction","text":"CompositeCostFunction(f̄...)\n\nAlternate constructor, letting each function be passed as its own argument.\n\n\n\n\n\n","category":"method"},{"location":"CostFunctions/#CtrlVQE.CostFunctions.CompositeGradientFunction","page":"Cost Functions","title":"CtrlVQE.CostFunctions.CompositeGradientFunction","text":"CompositeGradientFunction(ḡ::Vector{AbstractCostFunction})\n\nThe sum of several other gradient-functions.\n\n\n\n\n\n","category":"type"},{"location":"CostFunctions/#CtrlVQE.CostFunctions.CompositeGradientFunction-Tuple","page":"Cost Functions","title":"CtrlVQE.CostFunctions.CompositeGradientFunction","text":"CompositeGradientFunction(ḡ...)\n\nAlternate constructor, letting each function be passed as its own argument.\n\n\n\n\n\n","category":"method"},{"location":"CostFunctions/#Energy-Functions","page":"Cost Functions","title":"Energy Functions","text":"","category":"section"},{"location":"CostFunctions/","page":"Cost Functions","title":"Cost Functions","text":"Modules = [\n    CtrlVQE.CostFunctions.EnergyFunctions.BareEnergy,\n    CtrlVQE.CostFunctions.EnergyFunctions.ProjectedEnergy,\n    CtrlVQE.CostFunctions.EnergyFunctions.NormalizedEnergy,\n    CtrlVQE.CostFunctions.EnergyFunctions.Normalization,\n]","category":"page"},{"location":"CostFunctions/#CtrlVQE.CostFunctions.EnergyFunctions.BareEnergy.functions-Tuple{AbstractMatrix, AbstractVector, Real, CtrlVQE.Devices.Device, Int64}","page":"Cost Functions","title":"CtrlVQE.CostFunctions.EnergyFunctions.BareEnergy.functions","text":"functions(O0, ψ0, T, device, r; kwargs...)\n\nCost and gradient functions for the expectation value of a Hermitian observable.\n\nThe frame rotation (if provided) is applied to the molecular hamiltonian,     rather than to the state.\n\nArguments\n\nO0: a Hermitian matrix, living in the physical Hilbert space of device.\nψ0: the reference state, living in the physical Hilbert space of device.\nT::Real: the total time for the state to evolve under the device Hamiltonian.\ndevice::Devices.Device: the device\nr::Int: the number of time steps to calculate the gradient signal\n\nKeyword Arguments\n\nalgorithm::Evolutions.Algorithm: which algorithm to evolve ψ0 with.       Defaults to Evolutions.rotate(r).\nbasis::Bases.BasisType: which basis O0 and ψ0 are represented in.       ALSO determines the basis in which time-evolution is carried out.       Defaults to Bases.OCCUPATION.\nframe::Operators.StaticOperator: which frame to measure expecation values in.       Use Operators.STATIC for the drive frame,           which preserves the reference energy for a zero pulse.       Use Operators.UNCOUPLED for the interaction frame,           a (presumably) classically tractable approximation to the drive frame.       Defaults to Operators.IDENTITY.\n\nReturns\n\nf: the cost function\ng: the gradient function\n\n\n\n\n\n","category":"method"},{"location":"CostFunctions/#CtrlVQE.CostFunctions.EnergyFunctions.ProjectedEnergy.functions-Tuple{AbstractMatrix, AbstractVector, Real, CtrlVQE.Devices.Device, Int64}","page":"Cost Functions","title":"CtrlVQE.CostFunctions.EnergyFunctions.ProjectedEnergy.functions","text":"functions(O0, ψ0, T, device, r; kwargs...)\n\nCost and gradient functions for the expectation value of a Hermitian observable.\n\nThe statevector is projected onto a binary logical space after time evolution,     modeling an ideal quantum measurement where leakage is fully characterized.\n\nThe frame rotation (if provided) is applied to the molecular hamiltonian,     rather than to the state.\n\nArguments\n\nO0: a Hermitian matrix, living in the physical Hilbert space of device.\nψ0: the reference state, living in the physical Hilbert space of device.\nT::Real: the total time for the state to evolve under the device Hamiltonian.\ndevice::Devices.Device: the device\nr::Int: the number of time steps to calculate the gradient signal\n\nKeyword Arguments\n\nalgorithm::Evolutions.Algorithm: which algorithm to evolve ψ0 with.       Defaults to Evolutions.rotate(r).\nbasis::Bases.BasisType: which basis O0 and ψ0 are represented in.       ALSO determines the basis in which time-evolution is carried out.       Defaults to Bases.OCCUPATION.\nframe::Operators.StaticOperator: which frame to measure expecation values in.       Use Operators.STATIC for the drive frame,           which preserves the reference energy for a zero pulse.       Use Operators.UNCOUPLED for the interaction frame,           a (presumably) classically tractable approximation to the drive frame.       Defaults to Operators.IDENTITY.\n\nReturns\n\nf: the cost function\ng: the gradient function\n\n\n\n\n\n","category":"method"},{"location":"CostFunctions/#CtrlVQE.CostFunctions.EnergyFunctions.NormalizedEnergy.functions-Tuple{AbstractMatrix, AbstractVector, Real, CtrlVQE.Devices.Device, Int64}","page":"Cost Functions","title":"CtrlVQE.CostFunctions.EnergyFunctions.NormalizedEnergy.functions","text":"functions(O0, ψ0, T, device, r; kwargs...)\n\nCost and gradient functions for the expectation value of a Hermitian observable.\n\nThe statevector is projected onto a binary logical space after time evolution,     and then renormalized,     modeling quantum measurement where leakage is completely obscured.\n\nThe frame rotation (if provided) is applied to the molecular hamiltonian,     rather than to the state.\n\nArguments\n\nO0: a Hermitian matrix, living in the physical Hilbert space of device.\nψ0: the reference state, living in the physical Hilbert space of device.\nT::Real: the total time for the state to evolve under the device Hamiltonian.\ndevice::Devices.Device: the device\nr::Int: the number of time steps to calculate the gradient signal\n\nKeyword Arguments\n\nalgorithm::Evolutions.Algorithm: which algorithm to evolve ψ0 with.       Defaults to Evolutions.rotate(r).\nbasis::Bases.BasisType: which basis O0 and ψ0 are represented in.       ALSO determines the basis in which time-evolution is carried out.       Defaults to Bases.OCCUPATION.\nframe::Operators.StaticOperator: which frame to measure expecation values in.       Use Operators.STATIC for the drive frame,           which preserves the reference energy for a zero pulse.       Use Operators.UNCOUPLED for the interaction frame,           a (presumably) classically tractable approximation to the drive frame.       Defaults to Operators.IDENTITY.\n\nReturns\n\nf: the cost function\ng: the gradient function\n\n\n\n\n\n","category":"method"},{"location":"CostFunctions/#CtrlVQE.CostFunctions.EnergyFunctions.Normalization.functions-Tuple{AbstractVector, Real, CtrlVQE.Devices.Device, Int64}","page":"Cost Functions","title":"CtrlVQE.CostFunctions.EnergyFunctions.Normalization.functions","text":"functions(ψ0, T, device, r; kwargs...)\n\nCost and gradient functions for the norm of a statevector in a binary logical space.\n\nArguments\n\nψ0: the reference state, living in the physical Hilbert space of device.\nT::Real: the total time for the state to evolve under the device Hamiltonian.\ndevice::Devices.Device: the device\nr::Int: the number of time steps to calculate the gradient signal\n\nKeyword Arguments\n\nalgorithm::Evolutions.Algorithm: which algorithm to evolve ψ0 with.       Defaults to Evolutions.rotate(r).\nbasis::Bases.BasisType: which basis O0 and ψ0 are represented in.       ALSO determines the basis in which time-evolution is carried out.       Defaults to Bases.OCCUPATION.\n\nReturns\n\nf: the cost function\ng: the gradient function\n\n\n\n\n\n","category":"method"},{"location":"CostFunctions/#Penalty-Functions","page":"Cost Functions","title":"Penalty Functions","text":"","category":"section"},{"location":"CostFunctions/","page":"Cost Functions","title":"Cost Functions","text":"Modules = [\n    CtrlVQE.CostFunctions.HardBounds,\n    CtrlVQE.CostFunctions.SoftBounds,\n    CtrlVQE.CostFunctions.SmoothBounds,\n]","category":"page"},{"location":"CostFunctions/#CtrlVQE.CostFunctions.HardBounds.functions-NTuple{4, Any}","page":"Cost Functions","title":"CtrlVQE.CostFunctions.HardBounds.functions","text":"functions(λ̄, x̄L, x̄R, σ̄)\n\nA steep exponential penalty for each parameter exceeding its bounds.\n\nArguments\n\nλ̄: vector of weights for each penalty       Set λ̄[i]=0 to skip penalties for the ith parameter.\nx̄L: vector of lower bounds for each parameter\nx̄R: vector of upper bounds for each parameter\nσ̄: vector of scalings (smaller=steeper) for each penalty\n\nReturns\n\nf: the cost function\ng: the gradient function\n\n\n\n\n\n","category":"method"},{"location":"CostFunctions/#CtrlVQE.CostFunctions.SoftBounds.functions-Tuple{Any, Any, Any}","page":"Cost Functions","title":"CtrlVQE.CostFunctions.SoftBounds.functions","text":"functions(λ̄, x̄L, x̄R, σ̄)\n\nA shallow quadratic penalty for each parameter's deviation from mean.\n\nArguments\n\nλ̄: vector of weights for each penalty       Set λ̄[i]=0 to skip penalties for the ith parameter.\nμ̄: vector of lower bounds for each parameter\nσ̄: vector of scalings (smaller=steeper) for each penalty\n\nReturns\n\nf: the cost function\ng: the gradient function\n\n\n\n\n\n","category":"method"},{"location":"CostFunctions/#CtrlVQE.CostFunctions.SmoothBounds.functions-NTuple{4, Any}","page":"Cost Functions","title":"CtrlVQE.CostFunctions.SmoothBounds.functions","text":"functions(λ̄, x̄L, x̄R, σ̄)\n\nA smooth exponential penalty for each parameter exceeding its bounds.\n\nArguments\n\nλ̄: vector of weights for each penalty       Set λ̄[i]=0 to skip penalties for the ith parameter.\nμ̄R: vector of lower bounds for each parameter\nμ̄L: vector of upper bounds for each parameter\nσ̄: vector of scalings (smaller=steeper) for each penalty\n\nReturns\n\nf: the cost function\ng: the gradient function\n\n\n\n\n\n","category":"method"},{"location":"","page":"CtrlVQE","title":"CtrlVQE","text":"CurrentModule = CtrlVQE","category":"page"},{"location":"#CtrlVQE","page":"CtrlVQE","title":"CtrlVQE","text":"","category":"section"},{"location":"","page":"CtrlVQE","title":"CtrlVQE","text":"Documentation for CtrlVQE.","category":"page"},{"location":"#Main-Modules","page":"CtrlVQE","title":"Main Modules","text":"","category":"section"},{"location":"","page":"CtrlVQE","title":"CtrlVQE","text":"Pages = [\n    \"Parameters.md\",\n    \"Bases.md\",\n    \"Operators.md\",\n    \"LinearAlgebraTools.md\",\n    \"Devices.md\",\n    \"Signals.md\",\n    \"Evolutions.md\",\n    \"QubitOperators.md\",\n    \"CostFunctions.md\",\n]","category":"page"},{"location":"#Recipes","page":"CtrlVQE","title":"Recipes","text":"","category":"section"},{"location":"","page":"CtrlVQE","title":"CtrlVQE","text":"Modules = [CtrlVQE]","category":"page"},{"location":"#CtrlVQE.FullyTrotterized-Tuple{CtrlVQE.Signals.AbstractSignal, Real, Int64}","page":"CtrlVQE","title":"CtrlVQE.FullyTrotterized","text":"FullyTrotterized(signal::Signals.AbstractSignal, T::Real, r::Int)\n\nBreak a signal up so that each time-step is parameterized separately.\n\nUsually you'll want to use this with constant signals.\n\n\n\n\n\n","category":"method"},{"location":"#CtrlVQE.Systematic-Tuple{Type{<:CtrlVQE.Devices.TransmonDevices.AbstractTransmonDevice}, Int64, Any}","page":"CtrlVQE","title":"CtrlVQE.Systematic","text":"Systematic(TransmonDeviceType, n, pulses; kwargs...)\n\nStandardized constructor for a somewhat realistic transmon device, but of arbitrary size.\n\nThis is a linearly coupled device,     with uniformly-spaced resonance frequencies,     and with all coupling and anharmonicity constants equal for each qubit. The actual values of each constant are meant to roughly approximate a typical IBM device.\n\nArguments\n\nTransmonDeviceType: the type of the device to be constructed\nn::Int: the number of qubits in the device\npulses: a vector of control signals (Signals.AbstractSignal), or one to be copied\n\nKeyword Arguments\n\nm::Int: the number of transmon levels to include in simulations (defaults to 2)\nF: the float type to use for device parameters (defaults to Float64)\n\n\n\n\n\n","category":"method"},{"location":"#CtrlVQE.UniformWindowed-Tuple{CtrlVQE.Signals.AbstractSignal, Real, Int64}","page":"CtrlVQE","title":"CtrlVQE.UniformWindowed","text":"UniformWindowed(signal::Signals.AbstractSignal, T::Real, W::Int)\n\nBreak a signal up into equal-sized windows.\n\nUsually you'll want to use this with constant signals.\n\n\n\n\n\n","category":"method"},{"location":"#Miscellaneous-Modules","page":"CtrlVQE","title":"Miscellaneous Modules","text":"","category":"section"},{"location":"#Quples","page":"CtrlVQE","title":"Quples","text":"","category":"section"},{"location":"","page":"CtrlVQE","title":"CtrlVQE","text":"Modules = [Quples]","category":"page"},{"location":"#CtrlVQE.Quples","page":"CtrlVQE","title":"CtrlVQE.Quples","text":"Quples\n\nQubit tuples: simple types to represent couplings within a device.\n\n\n\n\n\n","category":"module"},{"location":"#CtrlVQE.Quples.Quple","page":"CtrlVQE","title":"CtrlVQE.Quples.Quple","text":"Quple(q1,q2)\n\nA (symmetric) coupling between qubits indexed by q1 and q2.\n\nNote that the order is irrelevant: Quple(q1,q2) == Quple(q2,q1).\n\n\n\n\n\n","category":"type"},{"location":"#TempArrays","page":"CtrlVQE","title":"TempArrays","text":"","category":"section"},{"location":"","page":"CtrlVQE","title":"CtrlVQE","text":"TempArrays\nTempArrays.array","category":"page"},{"location":"#CtrlVQE.TempArrays","page":"CtrlVQE","title":"CtrlVQE.TempArrays","text":"TempArrays\n\nMaintain caches for pre-allocated arrays used only temporarily within a function.\n\nDo NOT use this module for arrays     whose data are accessible outside the function in which they are created.\n\n\n\n\n\n","category":"module"},{"location":"#CtrlVQE.TempArrays.array","page":"CtrlVQE","title":"CtrlVQE.TempArrays.array","text":"array(::F, shape::Tuple, index=nothing)\n\nFetch a temporary array with type F and shape shape.\n\nThe index parameter is an additional unique key,     allowing the module to cache mulitple arrays of the same type and shape. You should pass index=Symbol(@__MODULE__) to prevent collisions across modules. You may pass a tuple, eg. index=(Symbol(@__MODULE__), :otherkey)     to prevent collisions within a module.\n\n\n\n\n\narray(F::Type{<:Number}, shape::Tuple, index=nothing)\n\nSame as above but passing the type directly, rather than an instance of the type.\n\n\n\n\n\n","category":"function"}]
}
